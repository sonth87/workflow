import { nodeRegistry } from "../registry/NodeRegistry";
import type { BaseEdgeConfig, BaseNodeConfig } from "../types/base.types";
import dagre from "dagre";

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  sanitizedNodes?: BaseNodeConfig[];
  sanitizedEdges?: BaseEdgeConfig[];
}

export class AIValidationService {
  /**
   * Validates and sanitizes a workflow generated by AI.
   * 1. Checks node types against registry.
   * 2. Checks edge connectivity.
   * 3. Sanitizes node properties (removes non-existent fields).
   * 4. Auto-layouts the workflow.
   */
  static validateAndEnhanceWorkflow(
    nodes: BaseNodeConfig[],
    edges: BaseEdgeConfig[]
  ): ValidationResult {
    const errors: string[] = [];
    const nodeIds = new Set(nodes.map(n => n.id));

    // 1. Validate Node Types & Sanitize Properties
    const sanitizedNodes = nodes.map(node => {
      // Check type
      if (!nodeRegistry.has(node.type as string)) {
        errors.push(`Invalid node type: "${node.type}" (Node ID: ${node.id})`);
        return node;
      }

      // Sanitize properties
      const registryItem = nodeRegistry.get(node.type as string);
      const allowedProps = new Set(
        registryItem?.config.propertyDefinitions?.map(p => p.id) || []
      );

      // Always allow basic props like 'label', 'description' if they exist in schema or are standard
      // But usually 'label' is in data.label, not properties.

      const sanitizedProps: Record<string, unknown> = {};

      if (node.properties) {
        Object.entries(node.properties).forEach(([key, value]) => {
          // Allow if defined in schema OR if it's a known common property (optional check)
          if (allowedProps.has(key)) {
            sanitizedProps[key] = value;
          }
        });
      }

      return {
        ...node,
        properties: sanitizedProps,
        // Ensure data exists
        data: {
          ...node.data,
          label: node.data?.label || node.id,
        },
      };
    });

    // 2. Validate Edges
    const sanitizedEdges: BaseEdgeConfig[] = [];
    edges.forEach(edge => {
      if (!nodeIds.has(edge.source)) {
        errors.push(
          `Edge ${edge.id} references missing source node: ${edge.source}`
        );
      } else if (!nodeIds.has(edge.target)) {
        errors.push(
          `Edge ${edge.id} references missing target node: ${edge.target}`
        );
      } else {
        sanitizedEdges.push({
          ...edge,
          // Ensure type is sequence-flow if missing, or validate if needed.
          type: edge.type || "sequence-flow",
          // Ensure animated is set to true by default (matches UI defaultEdgeOptions)
          animated: edge.animated !== undefined ? edge.animated : true,
        });
      }
    });

    // 3. Check for Start Event
    const hasStart = sanitizedNodes.some(
      n => n.type && n.type.toLowerCase().includes("start")
    );
    if (!hasStart) {
      errors.push("Workflow missing Start Event.");
    }

    if (errors.length > 0) {
      return { valid: false, errors };
    }

    // 4. Auto Layout
    const layoutedNodes = this.applyAutoLayout(sanitizedNodes, sanitizedEdges);

    return {
      valid: true,
      errors: [],
      sanitizedNodes: layoutedNodes,
      sanitizedEdges: sanitizedEdges,
    };
  }

  /**
   * Applies Dagre layout to nodes
   */
  private static applyAutoLayout(
    nodes: BaseNodeConfig[],
    edges: BaseEdgeConfig[]
  ): BaseNodeConfig[] {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: "LR", nodesep: 170, ranksep: 200, align: "DL" }); // Balanced spacing
    g.setDefaultEdgeLabel(() => ({}));

    // Filter out special nodes (notes, annotations) for separate placement
    const specialNodeTypes = ["note", "annotation"];

    // Nodes to be auto-layouted by Dagre
    const layoutNodes = nodes.filter(
      n => !specialNodeTypes.includes(n.type as string)
    );
    // Special nodes to be placed manually
    const specialNodes = nodes.filter(n =>
      specialNodeTypes.includes(n.type as string)
    );

    // Add standard nodes to graph
    layoutNodes.forEach(node => {
      // Assume a default width/height for layout calculation if not present
      const width = node.type?.includes("Event") ? 50 : 150;
      const height = 80;
      g.setNode(node.id, { width, height });
    });

    // Add edges to graph (only if both source and target are in the layoutNodes)
    const layoutNodeIds = new Set(layoutNodes.map(n => n.id));
    edges.forEach(edge => {
      // Only add edge if both nodes are part of the dagre layout
      if (layoutNodeIds.has(edge.source) && layoutNodeIds.has(edge.target)) {
        g.setEdge(edge.source, edge.target);
      }
    });

    // Calculate layout
    dagre.layout(g);

    // Get graph dimensions to place special nodes below
    // Dagre graph usually has .graph() with width/height, but we can also find max Y from nodes.
    let maxY = 0;

    // Apply positions back to standard nodes and find bounds
    const processedLayoutNodes = layoutNodes.map(node => {
      const nodeWithPos = g.node(node.id);

      // Update max Y
      const bottomY = nodeWithPos.y + nodeWithPos.height / 2;
      if (bottomY > maxY) maxY = bottomY;

      return {
        ...node,
        position: {
          x: nodeWithPos.x - nodeWithPos.width / 2, // Center content
          y: nodeWithPos.y - nodeWithPos.height / 2,
        },
      };
    });

    // Place special nodes below the layout
    const startY = maxY + 50; // 50px padding below the graph
    let currentX = 0;
    const spacingX = 350; // Horizontal spacing between notes

    const processedSpecialNodes = specialNodes.map(node => {
      const x = currentX;
      // Stagger them horizontally
      currentX += spacingX;

      return {
        ...node,
        position: {
          x: x,
          y: startY,
        },
      };
    });

    return [...processedLayoutNodes, ...processedSpecialNodes];
  }
}
