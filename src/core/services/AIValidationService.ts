import { nodeRegistry } from "../registry/NodeRegistry";
import type { BaseEdgeConfig, BaseNodeConfig } from "../types/base.types";
import dagre from "dagre";

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  sanitizedNodes?: BaseNodeConfig[];
  sanitizedEdges?: BaseEdgeConfig[];
}

export class AIValidationService {
  /**
   * Validates and sanitizes a workflow generated by AI.
   * 1. Checks node types against registry.
   * 2. Checks edge connectivity.
   * 3. Sanitizes node properties (removes non-existent fields).
   * 4. Auto-layouts the workflow.
   */
  static validateAndEnhanceWorkflow(
    nodes: BaseNodeConfig[],
    edges: BaseEdgeConfig[]
  ): ValidationResult {
    const errors: string[] = [];
    const nodeIds = new Set(nodes.map(n => n.id));

    // 1. Validate Node Types & Sanitize Properties
    const sanitizedNodes = nodes.map(node => {
      // Check type
      if (!nodeRegistry.has(node.type as string)) {
        errors.push(`Invalid node type: "${node.type}" (Node ID: ${node.id})`);
        return node;
      }

      // Sanitize properties
      const registryItem = nodeRegistry.get(node.type as string);
      const allowedProps = new Set(
        registryItem?.config.propertyDefinitions?.map(p => p.id) || []
      );

      // Always allow basic props like 'label', 'description' if they exist in schema or are standard
      // But usually 'label' is in data.label, not properties.

      const sanitizedProps: Record<string, unknown> = {};

      if (node.properties) {
        Object.entries(node.properties).forEach(([key, value]) => {
          // Allow if defined in schema OR if it's a known common property (optional check)
          if (allowedProps.has(key)) {
            sanitizedProps[key] = value;
          }
        });
      }

      return {
        ...node,
        properties: sanitizedProps,
        // Ensure data exists
        data: {
          ...node.data,
          label: node.data?.label || node.id,
        },
      };
    });

    // 2. Validate Edges
    const sanitizedEdges: BaseEdgeConfig[] = [];
    edges.forEach(edge => {
      if (!nodeIds.has(edge.source)) {
        errors.push(
          `Edge ${edge.id} references missing source node: ${edge.source}`
        );
      } else if (!nodeIds.has(edge.target)) {
        errors.push(
          `Edge ${edge.id} references missing target node: ${edge.target}`
        );
      } else {
        sanitizedEdges.push({
          ...edge,
          // Ensure type is sequence-flow if missing, or validate if needed.
          type: edge.type || "sequence-flow",
        });
      }
    });

    // 3. Check for Start Event
    const hasStart = sanitizedNodes.some(
      n => n.type && n.type.toLowerCase().includes("start")
    );
    if (!hasStart) {
      errors.push("Workflow missing Start Event.");
    }

    if (errors.length > 0) {
      return { valid: false, errors };
    }

    // 4. Auto Layout
    const layoutedNodes = this.applyAutoLayout(sanitizedNodes, sanitizedEdges);

    return {
      valid: true,
      errors: [],
      sanitizedNodes: layoutedNodes,
      sanitizedEdges: sanitizedEdges,
    };
  }

  /**
   * Applies Dagre layout to nodes
   */
  private static applyAutoLayout(
    nodes: BaseNodeConfig[],
    edges: BaseEdgeConfig[]
  ): BaseNodeConfig[] {
    const g = new dagre.graphlib.Graph();
    g.setGraph({ rankdir: "LR", nodesep: 170, ranksep: 200, align: "DL" }); // Balanced spacing
    g.setDefaultEdgeLabel(() => ({}));

    // Add nodes to graph
    nodes.forEach(node => {
      // Assume a default width/height for layout calculation if not present
      // Most BPMN nodes are around 100x80 or 40x40 (events)
      const width = node.type?.includes("Event") ? 50 : 150;
      const height = 80;
      g.setNode(node.id, { width, height });
    });

    // Add edges to graph
    edges.forEach(edge => {
      g.setEdge(edge.source, edge.target);
    });

    // Calculate layout
    dagre.layout(g);

    // Apply positions back to nodes
    return nodes.map(node => {
      const nodeWithPos = g.node(node.id);
      return {
        ...node,
        position: {
          x: nodeWithPos.x - nodeWithPos.width / 2, // Center content
          y: nodeWithPos.y - nodeWithPos.height / 2,
        },
      };
    });
  }
}
