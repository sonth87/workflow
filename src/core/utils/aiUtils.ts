import { nodeRegistry } from "../registry/NodeRegistry";
import { edgeRegistry } from "../registry/EdgeRegistry";
import type { BaseEdgeConfig, BaseNodeConfig, MultilingualText } from "../types/base.types";

export interface AIPropertyDefinition {
  name: string;
  type: string;
  label?: string;
  description?: string;
  required?: boolean;
  options?: Array<{ label: string; value: string }>;
}

export interface AINodeDefinition {
  type: string;
  category?: string;
  title: string;
  description?: string;
  properties: AIPropertyDefinition[];
}

export interface AICapabilities {
  nodes: AINodeDefinition[];
  edges: string[]; // List of edge types
}

function resolveText(text: MultilingualText | undefined | string): string {
  if (!text) return "";
  if (typeof text === "string") return text;
  // @ts-ignore - access safe properties for multilingual objects
  return text.en || text.vi || (Object.values(text)[0] as string) || "";
}

/**
 * Extracts a simplified schema of all registered nodes and edges.
 * This schema is optimized for AI consumption to understand available building blocks.
 */
export function getRegistryCapabilities(): AICapabilities {
  const allNodes = nodeRegistry.getAll();
  const allEdges = edgeRegistry.getAll();

  const nodes: AINodeDefinition[] = allNodes.map((item) => {
    const config = item.config;
    const meta = config.metadata || {};

    // Map property definitions to a simplified format
    const properties: AIPropertyDefinition[] = (config.propertyDefinitions || []).map((prop: any) => ({
      name: prop.id,
      type: prop.type,
      label: resolveText(prop.label),
      description: resolveText(prop.description),
      required: prop.required,
      options: Array.isArray(prop.options) ? prop.options.map((opt: any) => ({
        label: resolveText(opt.label),
        value: opt.value
      })) : undefined,
    }));

    // Resolve node title/desc
    let title = resolveText(meta.title);
    if (!title) title = resolveText(item.name);
    if (!title) title = item.id;

    const description = resolveText(meta.description) || resolveText(item.description);

    return {
      type: item.id, // The registry ID is the node type
      category: item.category || config.category,
      title: title,
      description: description,
      properties,
    };
  });

  const edges = allEdges.map((item) => item.id);

  return {
    nodes,
    edges,
  };
}

export interface ValidationResult {
    valid: boolean;
    errors: string[];
}

/**
 * Validates a workflow generated by AI.
 * Checks for: valid types, connectivity, and basic rules.
 */
export function validateGeneratedWorkflow(nodes: BaseNodeConfig[], edges: BaseEdgeConfig[]): ValidationResult {
    const errors: string[] = [];
    const nodeIds = new Set(nodes.map(n => n.id));

    // 1. Check Node Types
    nodes.forEach(node => {
        if (!nodeRegistry.has(node.type as string)) {
            errors.push(`Invalid node type: "${node.type}" (Node ID: ${node.id})`);
        }
    });

    // 2. Check Edges (Source/Target existence)
    edges.forEach(edge => {
        if (!nodeIds.has(edge.source)) {
            errors.push(`Edge ${edge.id} references missing source node: ${edge.source}`);
        }
        if (!nodeIds.has(edge.target)) {
            errors.push(`Edge ${edge.id} references missing target node: ${edge.target}`);
        }
    });

    // 3. Connectivity Check (Orphans)
    // Every node (except start/end potentially, though BPMN rules are stricter) usually has edges.
    // For now, let's just warn if a node has NO edges at all.
    nodes.forEach(node => {
        const hasIncoming = edges.some(e => e.target === node.id);
        const hasOutgoing = edges.some(e => e.source === node.id);

        // Start event should have outgoing. End event should have incoming.
        // Task/Gateway should have both.
        // This is a heuristic.
        if (!hasIncoming && !hasOutgoing) {
             // We won't block on this, but it's often a sign of hallucination.
             // errors.push(`Node disconnected: ${node.id}`);
        }
    });

    // 4. Check for Start Event presence
    const hasStart = nodes.some(n => n.type && n.type.toLowerCase().includes("start"));
    if (!hasStart) {
        errors.push("Workflow missing Start Event.");
    }

    return {
        valid: errors.length === 0,
        errors
    };
}
